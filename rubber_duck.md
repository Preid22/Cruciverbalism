                ** CROSSWORD APP RUBBER DUCK/NOTES **

## 1/13/2023

    Going to use this space to write out the thought processes and check my understanding of the code.

Issue at hand is getting all the cells associated with an answer to highlight when any cell
within the answer gets clicked.

Understanding that part of what needs to happen is having some sort of ID value that links cells
and answers, so when any given cell is clicked on and a re-render takes place NOT JUST the cell
selected will render a different color but all the cells that share the same answer ID as well.

ðŸš¨ NOT SURE ABOUT

- What to use for the key: an existing value or does one need to be generated?
- How will the key be accessed?
- How will the key be passed to the cell?

As I realized the other evening my understanding of how the app functions is not as thorough as
I thought. Lot's of uncertainty/ambiguity around where I was even getting confused prompted me to start explaining
my way through the app and addressing all areas that seem unclear.

Since I am currently struggling with an issue related to the rendering of cells that seemed like a good place to start-

- What are the cells?

  Each cell is a React component, <Cell />.
  Cell is currently being passed these props (details on these later): - focusCell (state) - gridnum (the cells corresponding clue number) - letter (the letter for that cell) - row (row coord) - column (column coord) - handleSetFocus

  Within the component, <Cell /> has a 'fill' variable that is assigned an anon func which performs a check on
  the LETTER prop. If the value of LETTER is '.' the function returns 'black', otherwise it returns 'white'.

(Cell.jsx/ln. 21)
const fill = () => {
if (letter === ".") {
return "black";
} else {
return "white";
}
};

    There is another variable, focusFill, that performs a similar check but with added logic to highlight a cell
    that gets clicked. It does the same check for '.' but there is also a conditional statement that compares
    the ROW and COLUMN props to the .row and .column properties of focusCell, if they are equal then the function
    returns 'yellow' and if not 'white'

(Cell.jsx/ln. 29)
const focusFill = () => {
if (letter === ".") {
return "black";
}
if (row === focusCell.row && column === focusCell.column) {
return "yellow";
} else {
return "white";
}
};

Why/how does this work? - ROW and COLUMN are props in <Cell />. Cells are generated by mapping
over the CELLS prop in <Grid />, which is an array of objects generated in newGameManager with each object having
properties for ROW, COLUMN, and LETTER. In <Cell />, the ROW and COLUMN props are derived from this and can be accessed.

focusCell allows us to pick a cell by clicking. The onClick event in <Cell /> fires the handleSetFocus function (defined
on ln.33 of Game.jsx) with the ROW and COLUMN props passed in as arguments. This updates the focusCell state, which is
output as an object with properties for row and column ({'row':'x', 'column':'y'}), which here are accessed and compared
to the 'static' row and col values. If they match, the cell is rendered with a yellow background.

After these function definitions the JSX is returned -

<g
onClick={() => {
handleSetFocus(row, column);
}}
style={{ cursor: "pointer" }}
className="clue-cell" >

    This is the first element. <g> is simply a wrapper used to contain other SVG elements. It has three attributes:
    onClick - which fires handleSetFocus with ROW and COLUMN (from the props) as it's args
    style - {{cursor: pointer}}
    className - 'clue-cell'

    Within this element there is a
    <rect> element which has attributes to determine it's size and position, as well as a fill attribute that
    sets the color by invoking the focusFill function defined on ln. 29

      <rect
        x={x + cellPadding}
        y={y + cellPadding}
        width={cellInner}
        height={cellInner}
        fill={focusFill()}
        stroke="black"
        strokeWidth={cellSize / 20}
      />

Within the <rect> element there are two text elements, one for the clue number and one for the answer letter
\*\*\* (come back to this)

This all gives us a <Cell /> component that can display two text elements and currently has access through props
to row and column coords as well as the correct letter for that spot.

## 1/16/2023

    Coming back to this after a couple of days. Understanding more clearly that the data we are passing by object

is what drives a lot of this. Didn't have a strong grasp on what the data looked like, what form it took and what
information was stored. Handling the data is key, main current challenge is to associate the answer letters with
clue numbers and grid coords.

Currently all the relevant CW data is stored in state variable 'board'.

- What data is accessible and what does it look like? What components have access?

* In Game.jsx state variable 'board' has these properties passed to it

- .answers - an object with keys for ACROSS and DOWN, for each key there is an array containing the correct answers
  as strings

              {
                  across:

  [ 'JAYS',
  'FRA',
  'HAZE',
  'EQUI',
  'HOUSE',
  'AGIN',
  'EURO' ]...,
  down:
  [ 'JEER',
  'AQUA',
  'YURI',
  'SION',
  'FOSTERED',
  'RUTS',
  'ASEASY' ]...
  }

- .author - author's name
- .size - grid dimensions
- .copyright
- .date
- .editor
- .publisher
- .title

- .acrossCluesArr - calls function generateClueArray, with puzzle.clues.across as an arg. clues is an object with keys for ACROSS and DOWN and each of those keys has an array of numbered clues
  (["1. a clue", "2. another clue"]).

The function maps over the object containing clues. variables num
and clueString are created by splitting the existing clue String('1. clue') and returning an object that has keys for NUM and CLUESTRING, populated by the respective data

                function generateClueArray(clues) {
            return clues.map((clue) => {
                const [num, clueString] = clue.split(".");
                return {
                num,
                clueString,
                };
            });
            }

    Outputs:
             [ { num: '1', clueString: ' Birds' },
               { num: '5', clueString: " Monk's title" },
               { num: '8', clueString: ' Weather word' },
               { num: '12', clueString: ' Same: Prefix' },
               { num: '13', clueString: ' See 37 Across' },
               { num: '15', clueString: ' Opposed, in Dogpatch' },
               { num: '16', clueString: ' Continental prefix' },
               { num: '17', clueString: ' Chemical compound' },
               { num: '18', clueString: ' Fruit covering' }...]

- .downCluesArr - same as across but down

- .acrossCluesMap - this uses a reduce function (STEP THRU THIS), it still uses 'clues' but this returns an object with numbered keys and
  the clues as properties

                  { '1': ' Birds',
                  '5': " Monk's title",
                  '8': ' Weather word',
                  '12': ' Same: Prefix',
                  '13': ' See 37 Across',
                  '15': ' Opposed, in Dogpatch',
                  '16': ' Continental prefix',
                  '17': ' Chemical compound',
                  '18': ' Fruit covering',
                  '19': ' Be pettish, as the weather',
                  '22': ' Verse form',
                  '23': ' Small whale',
                  '24': ' Coming-out girls'
                  }

- .downCluesMap - same but for down
- .cells - calls a func (generateCells) that takes GRID (see below)
  as it's first arg and the value of .size as the second. generateCells
  maps over GRID (an array of letter strings and '.') and returns an object w keys for LETTER, ROW, and COLUMN
  [
  "J",
  "A",
  "Y",
  "S",
  ".",
  ".",
  "F",
  "R",
  "A",
  ".",
  "."...
  ]

      ==

      [ { letter: 'J', row: 0, column: 0 },
        { letter: 'A', row: 0, column: 1 },
        { letter: 'Y', row: 0, column: 2 },
        { letter: 'S', row: 0, column: 3 },
        { letter: '.', row: 0, column: 4 },
        { letter: 'F', row: 0, column: 5 },
        { letter: 'R', row: 0, column: 6 },]

- .gridnums - an array of numbers (clue numbers)
  [ 1, 2, 3, 4, 0, 0, 5, 6, 7, 0, 0...]
